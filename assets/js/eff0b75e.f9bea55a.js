"use strict";(self.webpackChunkethda_docs=self.webpackChunkethda_docs||[]).push([[4546],{5721:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>b,frontMatter:()=>a,metadata:()=>r,toc:()=>c});var s=n(5893),o=n(1151),i=n(4996);const a={id:"technologies",title:"",hide_table_of_contents:!1},l=void 0,r={id:"overview/technologies",title:"",description:"Blob Transactions",source:"@site/docs/overview/technologies.md",sourceDirName:"overview",slug:"/overview/technologies",permalink:"/overview/technologies",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"technologies",title:"",hide_table_of_contents:!1},sidebar:"mySidebar",previous:{title:"",permalink:"/overview/blobsphere"},next:{title:"",permalink:"/resources/ethda-contracts"}},d={},c=[{value:"Blob Transactions",id:"blob-transactions",level:2},{value:"RPC Interfaces",id:"rpc-interfaces",level:3},{value:"Data Availability Sampling (DAS)",id:"data-availability-sampling-das",level:2}];function h(e){const t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h2,{id:"blob-transactions",children:"Blob Transactions"}),"\n",(0,s.jsx)(t.p,{children:"Blob Transaction (Blob TX) is the so-called DA Interface that rollups are supposed to use after Cancun-Deneb is deployed on Ethereum. A typical Blob TX looks like below:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-json",children:"{\n  chainId,\n  nonce,\n  to,\n  value,\n  data,\n  maxPriorityFeePerGas,\n  maxFeePerGas,\n  gasLimit,\n  maxFeePerBlobGas,\n  blobVersionedHashes,\n  blobs,\n  kzgCommitments,\n  kzgProofs\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Where ",(0,s.jsx)(t.code,{children:"blobs"})," is an encoded polynomial per ",(0,s.jsx)(t.a,{href:"https://eips.ethereum.org/EIPS/eip-4844",children:"EIP-4844"})," specification, ",(0,s.jsx)(t.code,{children:"kzgCommitments"})," is the KZG commitment of blobs, ",(0,s.jsx)(t.code,{children:"kzgProofs"})," is the KZG proof that is used to verify against the commitment, and ",(0,s.jsx)(t.code,{children:"blobVersionedHashes"})," is used as references to Blobs in Ethereum execution layer to ensure forward compatibility with future changes."]}),"\n",(0,s.jsx)(t.p,{children:"Blob TX support is crucial to enable rollups to seamlessly switch their DA layer between L1 and EthDA."}),"\n",(0,s.jsx)(t.h3,{id:"rpc-interfaces",children:"RPC Interfaces"}),"\n",(0,s.jsx)(t.p,{children:"EthDA does not introduce any new EVM RPC interfaces. Instead, we extend existing RPC interfaces to support Blob uploading and downloading via Blob TX."}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"eth_sendRawTransaction"}),(0,s.jsx)("br",{}),"\nSimilar to Ethereum L1, this RPC interface is used to post Blob TX to EthDA sequencers."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"eth_getTransactionByHash / eth_getTransactionByBlockHashAndIndex / eth_getTransactionByBlockNumberAndIndex"}),(0,s.jsx)("br",{}),"\nThis set of RPC interfaces could be used to download Blobs from EthDA. EthDA will check the requested transaction type, and if it's a Blob TX, the attached Blobs will be returned as part of the transaction data."]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"data-availability-sampling-das",children:"Data Availability Sampling (DAS)"}),"\n",(0,s.jsxs)(t.p,{children:["So, how are Blobs stored on EthDA? EthDA employs a set of ",(0,s.jsx)(t.em,{children:"decentralized Data Availability Nodes"}),", and uses DAS scheme to ensure Blob sharding and storage."]}),"\n",(0,s.jsx)(t.p,{children:"DAS on EthDA is an extended implementation of DAS on Ethereum beacon layer. In addition to that, EthDA is able to support permanent Blob storage instead of a short period of storage like 4 weeks."}),"\n",(0,s.jsx)(t.p,{children:"Similar to L1, DA nodes are randomly shuffled and split into N subnets. Each Blob is published to a subnet based on their index, and that subnet will be responsible for storing the Blob and ensuring its availability as a whole."}),"\n",(0,s.jsx)(t.p,{children:"DA node, however, does not need to store the whole Blob assigned to the subnet it belongs to. Instead, a Blob is split into multiple slices and DA nodes will randomly sample each other to make sure the Blob is stored by the whole subnet.\nThe whole subnet architecture is a grid structure of N horizontal subnets and M vertical subnets."}),"\n",(0,s.jsx)("div",{style:{textAlign:"center"},children:(0,s.jsx)("img",{src:(0,i.Z)("/img/overview/technologies/das.png"),style:{width:560}})})]})}function b(e={}){const{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}}}]);