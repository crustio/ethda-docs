"use strict";(self.webpackChunkethda_docs=self.webpackChunkethda_docs||[]).push([[4546],{5721:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>b,frontMatter:()=>i,metadata:()=>r,toc:()=>h});var n=s(5893),o=s(1151),a=s(4996);const i={id:"technologies",title:"",hide_table_of_contents:!1},l=void 0,r={id:"overview/technologies",title:"",description:"Blob Transactions",source:"@site/docs/overview/technologies.md",sourceDirName:"overview",slug:"/overview/technologies",permalink:"/overview/technologies",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"technologies",title:"",hide_table_of_contents:!1},sidebar:"mySidebar",previous:{title:"",permalink:"/overview/blobsphere"},next:{title:"",permalink:"/resources/ethda-contracts"}},c={},h=[{value:"Blob Transactions",id:"blob-transactions",level:2},{value:"RPC Interfaces",id:"rpc-interfaces",level:3},{value:"Data Availability Sampling (DAS)",id:"data-availability-sampling-das",level:2},{value:"Blobweave",id:"blobweave",level:2}];function d(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h2,{id:"blob-transactions",children:"Blob Transactions"}),"\n",(0,n.jsx)(t.p,{children:"Blob Transaction (Blob TX) is the so-called DA Interface that rollups are supposed to use after Cancun-Deneb is deployed on Ethereum. A typical Blob TX looks like below:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-json",children:"{\n  chainId,\n  nonce,\n  to,\n  value,\n  data,\n  maxPriorityFeePerGas,\n  maxFeePerGas,\n  gasLimit,\n  maxFeePerBlobGas,\n  blobVersionedHashes,\n  blobs,\n  kzgCommitments,\n  kzgProofs\n}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["Where blobs is an encoded polynomial per ",(0,n.jsx)(t.a,{href:"https://eips.ethereum.org/EIPS/eip-4844",children:"EIP-4844"})," specification, kzgCommitments is the KZG commitment of blobs, kzgProofs is the KZG proof that is used to verify against the commitment, and blobVersionedHashes is used as references to Blobs in Ethereum execution layer to ensure forward compatibility with future changes."]}),"\n",(0,n.jsx)(t.p,{children:"Blob TX support is crucial to enable rollups to seamlessly switch their DA layer between L1 and EthDA."}),"\n",(0,n.jsx)(t.h3,{id:"rpc-interfaces",children:"RPC Interfaces"}),"\n",(0,n.jsx)(t.p,{children:"EthDA does not introduce any new EVM RPC interfaces. Instead, we extend existing RPC interfaces to support Blob uploading and downloading via Blob TX."}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"eth_sendRawTransaction"}),(0,n.jsx)("br",{}),"\nSimilar to Ethereum L1, this RPC interface is used to post Blob TX to EthDA sequencers."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"eth_getTransactionByHash / eth_getTransactionByBlockHashAndIndex / eth_getTransactionByBlockNumberAndIndex"}),(0,n.jsx)("br",{}),"\nThis set of RPC interfaces could be used to download Blobs from EthDA. EthDA will check the requested transaction type, and if it's a Blob TX, the attached Blobs will be returned as part of the transaction data."]}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"data-availability-sampling-das",children:"Data Availability Sampling (DAS)"}),"\n",(0,n.jsx)(t.p,{children:"So, how are Blobs stored on EthDA? EthDA employs a set of decentralized sequencers, and uses DAS scheme to ensure Blob sharding and storage."}),"\n",(0,n.jsx)(t.p,{children:"DAS on EthDA is an extended implementation of DAS on Ethereum beacon layer. In addition to that, EthDA is able to support permanent Blob storage instead of a short period of storage like 4 weeks."}),"\n",(0,n.jsx)(t.p,{children:"Similar to L1, sequencers are randomly shuffled and split into N subnets. Each Blob is published to a subnet based on their index, and that subnet will be responsible for storing the Blob and ensuring its availability as a whole."}),"\n",(0,n.jsx)(t.p,{children:"Sequencer node, however, does not need to store the whole Blob assigned to the subnet it belongs to. Instead, a Blob is split into multiple slices and sequencers will randomly sample each other to make sure the Blob is stored by the whole subnet.\nThe whole subnet architecture is a grid structure of N horizontal subnets and M vertical subnets."}),"\n",(0,n.jsx)("div",{style:{textAlign:"center"},children:(0,n.jsx)("img",{src:(0,a.Z)("/img/overview/technologies/das.png"),style:{width:560}})}),"\n",(0,n.jsx)(t.h2,{id:"blobweave",children:"Blobweave"}),"\n",(0,n.jsx)(t.p,{children:"There is a soft consensus mechanism among EthDA's sequencer network to produce L2 blocks (aka transaction bundles, or sequences) and submit ZK proofs to L1. To support Blob permanent storage by the sequencer network, EthDA uses a scheme called Blobweave similar to Arweave's Blockweave."}),"\n",(0,n.jsx)(t.p,{children:"Basically, the sequencer network maintains the L2 block hash list, a list of the hashes of all previous L2 blocks. The L2 block hash is calculated based on transaction data bundled into the block, including the carried Blobs. Moreover, a historical block with Blob TX is randomly selected to be the recall block. Transactions of the recall block are hashed alongside to generate the new block hash, thus forming a weave of blobs which we call Blobweave."}),"\n",(0,n.jsx)("div",{style:{textAlign:"center"},children:(0,n.jsx)("img",{src:(0,a.Z)("/img/overview/technologies/blobweave.png"),style:{width:560}})})]})}function b(e={}){const{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}}}]);